schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Account {
    """
    Account address
    """
    id: ID!
    """
    Tranche token balances that this account holds
    """
    balances(
        skip: Int = 0
        first: Int = 100
        orderBy: AccountBalance_orderBy
        orderDirection: OrderDirection
        where: AccountBalance_filter
    ): [AccountBalance!]!
}

type AccountBalance {
    """
    Equals to: <accountAddress>-<tokenAddress>
    """
    id: ID!
    """
    Account address
    """
    account: Account!
    """
    Tranche token address
    """
    tranche: Tranche!
    """
    Current account balance
    """
    amount: BigInt!
    """
    Block number in which the balance was last modified
    """
    block: BigInt
    """
    Last modified timestamp in seconds
    """
    modified: BigInt
    """
    Hash of the last transaction that modified the balance
    """
    transaction: Bytes
}

input AccountBalance_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    account: String
    account_not: String
    account_gt: String
    account_lt: String
    account_gte: String
    account_lte: String
    account_in: [String!]
    account_not_in: [String!]
    account_contains: String
    account_contains_nocase: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_: Account_filter
    tranche: String
    tranche_not: String
    tranche_gt: String
    tranche_lt: String
    tranche_gte: String
    tranche_lte: String
    tranche_in: [String!]
    tranche_not_in: [String!]
    tranche_contains: String
    tranche_contains_nocase: String
    tranche_not_contains: String
    tranche_not_contains_nocase: String
    tranche_starts_with: String
    tranche_starts_with_nocase: String
    tranche_not_starts_with: String
    tranche_not_starts_with_nocase: String
    tranche_ends_with: String
    tranche_ends_with_nocase: String
    tranche_not_ends_with: String
    tranche_not_ends_with_nocase: String
    tranche_: Tranche_filter
    amount: BigInt
    amount_not: BigInt
    amount_gt: BigInt
    amount_lt: BigInt
    amount_gte: BigInt
    amount_lte: BigInt
    amount_in: [BigInt!]
    amount_not_in: [BigInt!]
    block: BigInt
    block_not: BigInt
    block_gt: BigInt
    block_lt: BigInt
    block_gte: BigInt
    block_lte: BigInt
    block_in: [BigInt!]
    block_not_in: [BigInt!]
    modified: BigInt
    modified_not: BigInt
    modified_gt: BigInt
    modified_lt: BigInt
    modified_gte: BigInt
    modified_lte: BigInt
    modified_in: [BigInt!]
    modified_not_in: [BigInt!]
    transaction: Bytes
    transaction_not: Bytes
    transaction_gt: Bytes
    transaction_lt: Bytes
    transaction_gte: Bytes
    transaction_lte: Bytes
    transaction_in: [Bytes!]
    transaction_not_in: [Bytes!]
    transaction_contains: Bytes
    transaction_not_contains: Bytes
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum AccountBalance_orderBy {
    id
    account
    tranche
    amount
    block
    modified
    transaction
}

input Account_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    balances_: AccountBalance_filter
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum Account_orderBy {
    id
    balances
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

type Bond {
    """
    bond address
    """
    id: ID!
    """
    address of the creator
    """
    creator: String!
    """
    Deposit limit of the bond
    """
    depositLimit: BigInt!
    """
    address of the owner
    """
    owner: String!
    """
    reference to the collateral token
    """
    collateral: Token!
    """
    The tranches and ratios in a list
    """
    tranches(
        skip: Int = 0
        first: Int = 100
        orderBy: Tranche_orderBy
        orderDirection: OrderDirection
        where: Tranche_filter
    ): [Tranche!]!
    """
    The fee collected by bond owner
    """
    feeBps: BigInt!
    """
    The unix timestamp when this bond was created
    """
    startDate: BigInt!
    """
    date of when bond can first be matured as a unix timestamp
    """
    maturityDate: BigInt!
    """
    date bond was matured as a unix timestamp
    """
    maturedDate: BigInt
    """
    true if this bond is mature, else false
    """
    isMature: Boolean!
    """
    Total amount of debt distributed. Equal to the sum of tranche total supplies
    """
    totalDebt: BigInt!
    """
    Total amount of debt distributed at time bond matured. Equal to the sum of tranche total supplies
    """
    totalDebtAtMaturity: BigInt
    """
    The amount of collateral locked in this bond
    """
    totalCollateral: BigInt!
    """
    The amount of collateral locked in this bond at time bond matured
    """
    totalCollateralAtMaturity: BigInt
    """
    This property facilitates searching by asset, using 'tokenNames_contains' to match Bond entities on substring matches. This field has the value of collateral and tranche asset addresses and symbols concatenated.
    """
    tokenNames: String!
    """
    This property facilitates sorting by collateral asset symbol
    """
    collateralSymbol: String!
}

input Bond_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    creator: String
    creator_not: String
    creator_gt: String
    creator_lt: String
    creator_gte: String
    creator_lte: String
    creator_in: [String!]
    creator_not_in: [String!]
    creator_contains: String
    creator_contains_nocase: String
    creator_not_contains: String
    creator_not_contains_nocase: String
    creator_starts_with: String
    creator_starts_with_nocase: String
    creator_not_starts_with: String
    creator_not_starts_with_nocase: String
    creator_ends_with: String
    creator_ends_with_nocase: String
    creator_not_ends_with: String
    creator_not_ends_with_nocase: String
    depositLimit: BigInt
    depositLimit_not: BigInt
    depositLimit_gt: BigInt
    depositLimit_lt: BigInt
    depositLimit_gte: BigInt
    depositLimit_lte: BigInt
    depositLimit_in: [BigInt!]
    depositLimit_not_in: [BigInt!]
    owner: String
    owner_not: String
    owner_gt: String
    owner_lt: String
    owner_gte: String
    owner_lte: String
    owner_in: [String!]
    owner_not_in: [String!]
    owner_contains: String
    owner_contains_nocase: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    collateral: String
    collateral_not: String
    collateral_gt: String
    collateral_lt: String
    collateral_gte: String
    collateral_lte: String
    collateral_in: [String!]
    collateral_not_in: [String!]
    collateral_contains: String
    collateral_contains_nocase: String
    collateral_not_contains: String
    collateral_not_contains_nocase: String
    collateral_starts_with: String
    collateral_starts_with_nocase: String
    collateral_not_starts_with: String
    collateral_not_starts_with_nocase: String
    collateral_ends_with: String
    collateral_ends_with_nocase: String
    collateral_not_ends_with: String
    collateral_not_ends_with_nocase: String
    collateral_: Token_filter
    tranches: [String!]
    tranches_not: [String!]
    tranches_contains: [String!]
    tranches_contains_nocase: [String!]
    tranches_not_contains: [String!]
    tranches_not_contains_nocase: [String!]
    tranches_: Tranche_filter
    feeBps: BigInt
    feeBps_not: BigInt
    feeBps_gt: BigInt
    feeBps_lt: BigInt
    feeBps_gte: BigInt
    feeBps_lte: BigInt
    feeBps_in: [BigInt!]
    feeBps_not_in: [BigInt!]
    startDate: BigInt
    startDate_not: BigInt
    startDate_gt: BigInt
    startDate_lt: BigInt
    startDate_gte: BigInt
    startDate_lte: BigInt
    startDate_in: [BigInt!]
    startDate_not_in: [BigInt!]
    maturityDate: BigInt
    maturityDate_not: BigInt
    maturityDate_gt: BigInt
    maturityDate_lt: BigInt
    maturityDate_gte: BigInt
    maturityDate_lte: BigInt
    maturityDate_in: [BigInt!]
    maturityDate_not_in: [BigInt!]
    maturedDate: BigInt
    maturedDate_not: BigInt
    maturedDate_gt: BigInt
    maturedDate_lt: BigInt
    maturedDate_gte: BigInt
    maturedDate_lte: BigInt
    maturedDate_in: [BigInt!]
    maturedDate_not_in: [BigInt!]
    isMature: Boolean
    isMature_not: Boolean
    isMature_in: [Boolean!]
    isMature_not_in: [Boolean!]
    totalDebt: BigInt
    totalDebt_not: BigInt
    totalDebt_gt: BigInt
    totalDebt_lt: BigInt
    totalDebt_gte: BigInt
    totalDebt_lte: BigInt
    totalDebt_in: [BigInt!]
    totalDebt_not_in: [BigInt!]
    totalDebtAtMaturity: BigInt
    totalDebtAtMaturity_not: BigInt
    totalDebtAtMaturity_gt: BigInt
    totalDebtAtMaturity_lt: BigInt
    totalDebtAtMaturity_gte: BigInt
    totalDebtAtMaturity_lte: BigInt
    totalDebtAtMaturity_in: [BigInt!]
    totalDebtAtMaturity_not_in: [BigInt!]
    totalCollateral: BigInt
    totalCollateral_not: BigInt
    totalCollateral_gt: BigInt
    totalCollateral_lt: BigInt
    totalCollateral_gte: BigInt
    totalCollateral_lte: BigInt
    totalCollateral_in: [BigInt!]
    totalCollateral_not_in: [BigInt!]
    totalCollateralAtMaturity: BigInt
    totalCollateralAtMaturity_not: BigInt
    totalCollateralAtMaturity_gt: BigInt
    totalCollateralAtMaturity_lt: BigInt
    totalCollateralAtMaturity_gte: BigInt
    totalCollateralAtMaturity_lte: BigInt
    totalCollateralAtMaturity_in: [BigInt!]
    totalCollateralAtMaturity_not_in: [BigInt!]
    tokenNames: String
    tokenNames_not: String
    tokenNames_gt: String
    tokenNames_lt: String
    tokenNames_gte: String
    tokenNames_lte: String
    tokenNames_in: [String!]
    tokenNames_not_in: [String!]
    tokenNames_contains: String
    tokenNames_contains_nocase: String
    tokenNames_not_contains: String
    tokenNames_not_contains_nocase: String
    tokenNames_starts_with: String
    tokenNames_starts_with_nocase: String
    tokenNames_not_starts_with: String
    tokenNames_not_starts_with_nocase: String
    tokenNames_ends_with: String
    tokenNames_ends_with_nocase: String
    tokenNames_not_ends_with: String
    tokenNames_not_ends_with_nocase: String
    collateralSymbol: String
    collateralSymbol_not: String
    collateralSymbol_gt: String
    collateralSymbol_lt: String
    collateralSymbol_gte: String
    collateralSymbol_lte: String
    collateralSymbol_in: [String!]
    collateralSymbol_not_in: [String!]
    collateralSymbol_contains: String
    collateralSymbol_contains_nocase: String
    collateralSymbol_not_contains: String
    collateralSymbol_not_contains_nocase: String
    collateralSymbol_starts_with: String
    collateralSymbol_starts_with_nocase: String
    collateralSymbol_not_starts_with: String
    collateralSymbol_not_starts_with_nocase: String
    collateralSymbol_ends_with: String
    collateralSymbol_ends_with_nocase: String
    collateralSymbol_not_ends_with: String
    collateralSymbol_not_ends_with_nocase: String
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum Bond_orderBy {
    id
    creator
    depositLimit
    owner
    collateral
    tranches
    feeBps
    startDate
    maturityDate
    maturedDate
    isMature
    totalDebt
    totalDebtAtMaturity
    totalCollateral
    totalCollateralAtMaturity
    tokenNames
    collateralSymbol
}

scalar Bytes

type CollateralToken {
    """
    Token address
    """
    id: ID!
    """
    The token entity
    """
    token: Token!
}

input CollateralToken_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    token: String
    token_not: String
    token_gt: String
    token_lt: String
    token_gte: String
    token_lte: String
    token_in: [String!]
    token_not_in: [String!]
    token_contains: String
    token_contains_nocase: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_: Token_filter
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum CollateralToken_orderBy {
    id
    token
}

type Factory {
    """
    factory contract address
    """
    id: ID!
    """
    number of bonds created
    """
    bondCount: BigInt!
}

input Factory_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    bondCount: BigInt
    bondCount_not: BigInt
    bondCount_gt: BigInt
    bondCount_lt: BigInt
    bondCount_gte: BigInt
    bondCount_lte: BigInt
    bondCount_in: [BigInt!]
    bondCount_not_in: [BigInt!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum Factory_orderBy {
    id
    bondCount
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
    asc
    desc
}

type Query {
    factory(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Factory
    factories(
        skip: Int = 0
        first: Int = 100
        orderBy: Factory_orderBy
        orderDirection: OrderDirection
        where: Factory_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Factory!]!
    token(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        skip: Int = 0
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        where: Token_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Token!]!
    tranche(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Tranche
    tranches(
        skip: Int = 0
        first: Int = 100
        orderBy: Tranche_orderBy
        orderDirection: OrderDirection
        where: Tranche_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Tranche!]!
    bond(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bond
    bonds(
        skip: Int = 0
        first: Int = 100
        orderBy: Bond_orderBy
        orderDirection: OrderDirection
        where: Bond_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Bond!]!
    account(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        skip: Int = 0
        first: Int = 100
        orderBy: Account_orderBy
        orderDirection: OrderDirection
        where: Account_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Account!]!
    accountBalance(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountBalance
    accountBalances(
        skip: Int = 0
        first: Int = 100
        orderBy: AccountBalance_orderBy
        orderDirection: OrderDirection
        where: AccountBalance_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AccountBalance!]!
    collateralToken(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CollateralToken
    collateralTokens(
        skip: Int = 0
        first: Int = 100
        orderBy: CollateralToken_orderBy
        orderDirection: OrderDirection
        where: CollateralToken_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [CollateralToken!]!
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
}

type Subscription {
    factory(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Factory
    factories(
        skip: Int = 0
        first: Int = 100
        orderBy: Factory_orderBy
        orderDirection: OrderDirection
        where: Factory_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Factory!]!
    token(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokens(
        skip: Int = 0
        first: Int = 100
        orderBy: Token_orderBy
        orderDirection: OrderDirection
        where: Token_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Token!]!
    tranche(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Tranche
    tranches(
        skip: Int = 0
        first: Int = 100
        orderBy: Tranche_orderBy
        orderDirection: OrderDirection
        where: Tranche_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Tranche!]!
    bond(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Bond
    bonds(
        skip: Int = 0
        first: Int = 100
        orderBy: Bond_orderBy
        orderDirection: OrderDirection
        where: Bond_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Bond!]!
    account(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accounts(
        skip: Int = 0
        first: Int = 100
        orderBy: Account_orderBy
        orderDirection: OrderDirection
        where: Account_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [Account!]!
    accountBalance(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountBalance
    accountBalances(
        skip: Int = 0
        first: Int = 100
        orderBy: AccountBalance_orderBy
        orderDirection: OrderDirection
        where: AccountBalance_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [AccountBalance!]!
    collateralToken(
        id: ID!
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CollateralToken
    collateralTokens(
        skip: Int = 0
        first: Int = 100
        orderBy: CollateralToken_orderBy
        orderDirection: OrderDirection
        where: CollateralToken_filter
        """
        The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
        """
        block: Block_height
        """
        Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
        """
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): [CollateralToken!]!
    """
    Access to subgraph metadata
    """
    _meta(block: Block_height): _Meta_
}

type Token {
    """
    token address
    """
    id: ID!
    """
    token symbol
    """
    symbol: String!
    """
    token name
    """
    name: String!
    """
    token decimals
    """
    decimals: BigInt!
    """
    token total supply
    """
    totalSupply: BigInt!
}

input Token_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    symbol: String
    symbol_not: String
    symbol_gt: String
    symbol_lt: String
    symbol_gte: String
    symbol_lte: String
    symbol_in: [String!]
    symbol_not_in: [String!]
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    name: String
    name_not: String
    name_gt: String
    name_lt: String
    name_gte: String
    name_lte: String
    name_in: [String!]
    name_not_in: [String!]
    name_contains: String
    name_contains_nocase: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    decimals: BigInt
    decimals_not: BigInt
    decimals_gt: BigInt
    decimals_lt: BigInt
    decimals_gte: BigInt
    decimals_lte: BigInt
    decimals_in: [BigInt!]
    decimals_not_in: [BigInt!]
    totalSupply: BigInt
    totalSupply_not: BigInt
    totalSupply_gt: BigInt
    totalSupply_lt: BigInt
    totalSupply_gte: BigInt
    totalSupply_lte: BigInt
    totalSupply_in: [BigInt!]
    totalSupply_not_in: [BigInt!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum Token_orderBy {
    id
    symbol
    name
    decimals
    totalSupply
}

type Tranche {
    """
    tranche token address
    """
    id: ID!
    """
    reference to the bond in which this tranche belongs
    """
    bond: Bond!
    """
    reference to the tranche token contract
    """
    token: Token!
    """
    ratio of this tranche, all tranche ratios sum to 1000
    """
    ratio: BigInt!
    """
    index of this tranche, i.e. A-tranche is 0, B is 1 and so on
    """
    index: BigInt!
    """
    The amount of collateral in this tranche for redemption
    """
    totalCollateral: BigInt!
    """
    The amount of collateral in this tranche for redemption at time bond matured
    """
    totalCollateralAtMaturity: BigInt
    """
    token total supply at time bond matured
    """
    totalSupplyAtMaturity: BigInt
}

input Tranche_filter {
    id: ID
    id_not: ID
    id_gt: ID
    id_lt: ID
    id_gte: ID
    id_lte: ID
    id_in: [ID!]
    id_not_in: [ID!]
    bond: String
    bond_not: String
    bond_gt: String
    bond_lt: String
    bond_gte: String
    bond_lte: String
    bond_in: [String!]
    bond_not_in: [String!]
    bond_contains: String
    bond_contains_nocase: String
    bond_not_contains: String
    bond_not_contains_nocase: String
    bond_starts_with: String
    bond_starts_with_nocase: String
    bond_not_starts_with: String
    bond_not_starts_with_nocase: String
    bond_ends_with: String
    bond_ends_with_nocase: String
    bond_not_ends_with: String
    bond_not_ends_with_nocase: String
    bond_: Bond_filter
    token: String
    token_not: String
    token_gt: String
    token_lt: String
    token_gte: String
    token_lte: String
    token_in: [String!]
    token_not_in: [String!]
    token_contains: String
    token_contains_nocase: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_: Token_filter
    ratio: BigInt
    ratio_not: BigInt
    ratio_gt: BigInt
    ratio_lt: BigInt
    ratio_gte: BigInt
    ratio_lte: BigInt
    ratio_in: [BigInt!]
    ratio_not_in: [BigInt!]
    index: BigInt
    index_not: BigInt
    index_gt: BigInt
    index_lt: BigInt
    index_gte: BigInt
    index_lte: BigInt
    index_in: [BigInt!]
    index_not_in: [BigInt!]
    totalCollateral: BigInt
    totalCollateral_not: BigInt
    totalCollateral_gt: BigInt
    totalCollateral_lt: BigInt
    totalCollateral_gte: BigInt
    totalCollateral_lte: BigInt
    totalCollateral_in: [BigInt!]
    totalCollateral_not_in: [BigInt!]
    totalCollateralAtMaturity: BigInt
    totalCollateralAtMaturity_not: BigInt
    totalCollateralAtMaturity_gt: BigInt
    totalCollateralAtMaturity_lt: BigInt
    totalCollateralAtMaturity_gte: BigInt
    totalCollateralAtMaturity_lte: BigInt
    totalCollateralAtMaturity_in: [BigInt!]
    totalCollateralAtMaturity_not_in: [BigInt!]
    totalSupplyAtMaturity: BigInt
    totalSupplyAtMaturity_not: BigInt
    totalSupplyAtMaturity_gt: BigInt
    totalSupplyAtMaturity_lt: BigInt
    totalSupplyAtMaturity_gte: BigInt
    totalSupplyAtMaturity_lte: BigInt
    totalSupplyAtMaturity_in: [BigInt!]
    totalSupplyAtMaturity_not_in: [BigInt!]
    """
    Filter for the block changed event.
    """
    _change_block: BlockChangedFilter
}

enum Tranche_orderBy {
    id
    bond
    token
    ratio
    index
    totalCollateral
    totalCollateralAtMaturity
    totalSupplyAtMaturity
}

type _Block_ {
    """
    The hash of the block
    """
    hash: Bytes
    """
    The block number
    """
    number: Int!
    """
    Integer representation of the timestamp stored in blocks for the chain
    """
    timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
    """
    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    """
    The deployment ID
    """
    deployment: String!
    """
    If `true`, the subgraph encountered indexing errors at some past block
    """
    hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
    """
    Data will be returned even if the subgraph has indexing errors
    """
    allow
    """
    If the subgraph has indexing errors, data will be omitted. The default.
    """
    deny
}
